//가비지 컬렉션 , https://ko.javascript.info/garbage-collection
// 자바 스크립트는 눈에 보이지 않느 ㄴ곳에서 메모리 관리를 수행합니다.

//원시값 객체 함수 등 우리가 만드는 모든 것은 메모리를 차지합니다. 그렇다면 더는 쓸모 없어지게 된 것들으 ㄴ어떻게 처리될까요? 지금부턴 자바스크립트 엔진이 어떻게 필요 없는것을 찾아내 삭제하는지 알아 보겠습니다.

//가비지 컬렉션기준

//자바 스크립트는 도달 가능성(reachability)이라는 개념을 사용해 메모리 관리를 수행합니다.
// 도달가능한 값은 쉽게 말해 어떻게든 접근하거나 사용할 수 있는 값을 의미합니다. 도달가능한 값은 메모리에서 삭제되지 않습니다.

// 아래소개해 드릴 값들은 그 태생부터 도달 가능하기 때문에, 명백한 이유 없이느 ㄴ삭제되지 않습니다.

//예시:
// 현재 함수의 지역변수와 매개변수
// 중첩함수의 체인에 있는 함수에서 사용되는 변수와 매개변수
// 전역변수
// 기타등등
// 이런 값은 루트라고 부릅니다.
// 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 됩니다.
// 전역변수에 객체가 저장되어있다고 가정해 봅시다. 이 객체의 프로퍼티가 또 다른 객체를 참조하고 있다면, 프로퍼티가 참조하는 객체느 ㄴ도달 가능한 값이 됩니다.
// 이객체가 참조하는 다른 모든것들도 도달 가능하다고 여겨집니다. 자세한예시는아래에서 살펴보겠습니다.

//자바 스크립트 엔진 내에선 가비지 컬렉터(garbege collector) 가 끊임없이 동작합니다. 가비지 컬렉터느 ㄴ모든 객체를 모니터링 하고 도달할수 없는 객체느 ㄴ삭제합니다.

// 간단한예시
// 아주 간단한 예시가 있습니다.

//uesr엔 객체 참조 값이 저장됩니다.
let user = {
    name: "John"
};

// 이 그림에서 화살표는 객체 참조를 나타냅니다. 전역 변수"user"는 {name:"John"} (줄여서 John)이라는 객체를 참조합니다. 
// John의 프로퍼티 "name"은 원시값을 저장하고 있기 때문에 객체 안에 표현했습니다.

//user 의 값으 ㄹ다르 ㄴ값으로 덮어쓰면 참조 (화살표)가 사라집니다.

// user = null;

// 참조 두 개

// 참조를 user에서 admin으로 복사했다고 가정해봅시다.

// user엔 객체 참조 값이 저장됩니다.
let user = {
    name: "John"
};

let admin = user;

// 전역 변수 admin을 통하면 여전히 객체 John에 접근할수 있기 때문에 John은 메모리에서 삭제되지 않습니다. 
// 이 상태에서 admin을 다른값으로 덮어쓰면 John은 메모리에서 삭제될 수 있습니다.

//연결된 객체
// 이제 가족관계를 나타내는 복잡한 예시를 살펴보겠습니다.

function marry(man, woman) {
    woman.husband = man;
    man.wife = woman;

    return {
        father: man,
        mother : woman
    }
}

let family = marry({
    name:"John"
}, {
    name:"Ann"
});


//함수 marry 는 매개변수로 받은 두 객체를 서로 참조하게 하면서'결혼' 시키고, 두 객체를 포함하느 ㄴ새로운 객체를 반환합니다.
// 메모리 구조는 아래와 같이 나타낼수 있습니다

//지금은 모댄객체가 도달 가능한 상태입니다.
// 이제 참조 두개를 지워보겠습니다.

delete family.father;
delete family.mother.husband;

// 삭제한 두 개의 참조중 하나만 지웠다면, 모든 객체가 여전히 도달 가능한 상태였을 겁니다.
// 하지만 참조 두 개를 지우면 John으로 들어오는 참조는 모두 사라져 John은 도달 가능한 상태에서 벗어납니다.

// 외부로 나가느 ㄴ참조는 도달 가능한 상태에 영향을 주지 않습니다. 외부에서 들어오는 참조만이 도달 가능한 상태에 영향을 줍니다. 
// John은 이제 도달 가능한 상태가 아니기 때문에 메모리에서 제거됩니다. John에 저장된 데이터 역시 메모리에서 사라집니다.

//가비지 컬렉션 후 메모리 구조는 아래와 같습니다.


//도달할수 없는 섬

//객체들이 연결되어 섬 같은 구조를 만드는데, 이 섬에 도달할 방법이 없는경우, 섬을 구성하느 ㄴ객체 전부가 메모리에서 삭제됩니다.
// 근원 객체 family 가 아무것도 참조하지 않도록 해 봅시다.

family = null;

// 이제 메모리 내부 상태는 다음과 같아집니다.

// 도달할 수 없는 섬 예제는 도달 가능성이라는 개념이 얼마나 중요한지 보여줍니다.
// John 과 Ann은 여전히 서로를 참조하고 있고, 두 객체 모두 외부에서 들어오는 참조를 갖고 있지만, 이것만으로느 ㄴ충분하지 않다는걸 보여주죠
// family 객체와 루트 연결이 사라지만 루트 객체를 참조하는 것이 아무것도 없게 됩니다. 섬 전체가 도달할 수 없느 ㄴ상태가 되고 섬을 구성하는 객체 전부가 메모리에서 제거되죠

// 내부 알고리즘

// mark and sweep 이라 불리는 가비지 컬렉션 기본 알고리즘에 대해 알아봅시다.Ann은가비지 컬랙션은 대게 다음 단계를 거쳐 수행됩니다.
// 가비지 컬랙터느 ㄴ루트 정보를 수집하고 이를 기억합니다.
// 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 mark 합니다.
// mark된 모든 객체에 방문하고 그 객체들이 참조하느 ㄴ객체도 mark합니다 한번 방문한 객체느 ㄴ전부 mark 하기 때문에 같은 객체를 다시 방문하는 일은 없습니다.


