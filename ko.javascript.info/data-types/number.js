//숫자형
// 모던 자바스크립트는 숫자를 나타내는 두가지 자료형을 지원합니다
// 일반적인 숫자는 배정밀도 부동소수점 숫자 로 알려진 64비트 형식의 IEEE-754에 저장됩니다. 튜토리얼 전체에서 이형식을 사용하여 숫자를 표현할 예정입니다
// 2. 임의의 길이를 가진 정수 Bigint라는 새로운 자료형이 만들어졌습니다. 일반적인 숫자는 2^53이상이거나 -2^53이하 일수 없다는 제약때문에 Bigint라느 ㄴ새로운 자료형이 만들어졌습니다.
// Bigint는 아주 특별한 경우에만 사용되므로 별도의 챕터 Bigint에서 자세한 내용을 다루겠습니다.
// 자 그럼 일반적인 숫자에 대해서 자세히 알아봅시다

//숫자를 입력하는 다양한 방법
//10억을 입력해야한다고 상상해봅니다. 가장 분명한 방법은 아래와 같이 직접 10억을 써주는 것입니다.

let billion = 1000000000;

// 그런데 이렇게 0을 많이 사용해 숫자를 표현하다보면 잘못 입력하기 쉽기 떼문에, 실제로는 이런 방법을 잘 사용하지 않습니다.
// 0을 많이 입력하는게 귀찮기도 하지요. 그래서 대개는 10억(billion)을 나타낼땐 1bn을 사용하고 73억을 나타낼땐 7.3bn을 사용합니다 큰 숫자를 나타낼땐 이런방법이 주로 사용되죠
// 자바스크립트에서도 숫자 옆에 'e'를 붙이고 0의 개수를 그옆에 붙여주면 숫자를 줄일 수 있습니다.

let billion = 1e9; // 10억 , 1과 9개의 0
alert(7.3e9); // 73억

// 즉 'e'는 e왼쪽의 수에 e오른쪽에 있는 수만큼의 10의 거듭제곱을 곱하는 효과가 있습니다

 1e3 = 1* 1000
 1.23e6 = 1.23* 1000000

//  이제 아주 작은 숫자인 1마이크로를 표현해보겠습니다
let ms = 0.000001;
//  작은 숫자를 표현할 때도 큰 숫자를 표현할 때처럼 'e'를 사용할 수 있습니다. 0 을 명시적으로 쓰고싶지 않다면 다음과 같이 숫자를 표현할 수 잇죠.
let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동

// 0.000001 에서 0의 개수를 세면 6이므로 0.00001은 당연히 1e-6이 되죠.
// 이렇게 e 우측에 음수가 있으면, 이 음수의 절대값 만큼 10을 거듭제곱한 수로 나누는 것을 의미합니다

//10을 세번 거듭제곱한 수로 나눔
1e-3 = 1 / 1000;'(=0.001)'

// 10을 여섯 번 거듭제곱한 수로 나눔
1.23e-6 = 1.23 / 1000000; '(=0.0000123)'

// 16진수 2진수 8진수

//16진수는 색을 나타내거나 문자를 인코딩 할 때 등 다양한 곳에서 두루 쓰입니다. 
// 다양한 곳에서 쓰이는 만큼 당연히 16진수를 짧게 표현하는 방법도 존재하겠죠 16진수는 0x를 사용해 표현할 수 있습니다

//예시
alert(0xff) ; // 255
alert (0xFF); // 255 (대소문자를 가리지 않으므로 둘 다 같은 값을 나타냅니다)

// 2진수와 8진수는 아주 드물게 쓰이긴 하지만, 접두사 0b와 0o를 사용해 간단히 나타낼 수 있습니다.

let a = 0b1111111; // 255의 2진수
let b = 0o377; // 255의 8진수

alert(a==b); // true, 진법은 다르지만, a와 b는 같은 수임

//자바스크립트에서 지원하는 진법은 3개입니다. 이 외의 진법을 사용하려면 함수 paresInt를 사용해야 합니다(챕터 후반부에서 다룸).

//toString(base)
//num.toString(base) 메서드는 base 진법으로 num을 표현한 후, 이를 문자형으로 변환해 반환합니다.
// 예시 :

let num = 255;
alert (num.toString(16)); //ff
alert (num.toString(2)); // 1111111
// base는 2에서 36까지 쓸 수 있는데, 기본값은 10 입니다.
// base 별 유스 케이스는 다음과 같습니다.
// base=16 - 16진수 색 문자 인코딩 등을 표현할 때 사용합니다. 숫자는 0부터 9,10 이상의 수는 A부터 F를 사용하여 나타냅니다.
// base=2 - 비트 연산 디버깅에 주로 쓰입니다. 숫자는 0 또는 1이 될 수 있습니다.
// base=36 - 사용할수이쓴ㄴ base중 최대값으로, 0..9와 A..Z를 사용해 숫자를 표현합니다. 알파벳 전체가 숫자를 나타내는데 사용되죠 36 베이스는 URL을 줄이는것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용 합니다 예시를 살펴 봅시다
// 1.alert(123456..toString(36)); //2n9c

//점 두 개와 메서드 호출

//123456..toString(36)에 있는 점 두 개는 오타가 아닙니다 위 예시처럼 숫자를 대상으로 메서드 toString을 직접 호출하고 싶다면 숫자 다음에 점 두개..를 붙여야 합니다.
//123456.toString(36)처럼 점을 한개만 사용하면, 첫 번째 점 이후는 소수부로 인식되어 에러가 발생할 수 있습니다. 점을 하나 더 추가하면 자바 스크립트는 소수부가 없다고 판단하고 함수를 호출합니다.
//(123456).toString(36)도 가능합니다

// 어림수 구하기

//어림수를 구하는것(rounding)은 숫자를 다룰때 가장 많이 사용되는 연산 중 하나입니다.
//어림수 관련 내장 함수 몇가지를 살펴봅시다

//Math.floor
//소수점 첫째 자리에서 내림(버림) 3.1은 3, -1.1은 -2가 됩니다.

//Math.ceil
//소수점 첫째 자리에서 올림. 3.1은 4, -1.1은 -1이 됩니다

//Math.round
//소수점 첫째 자리에서 반올림. 3.1은 3, 3.6은 4, -1.1은 -1이 됩니다.

//Math.trunc (internet Explorer에서는 지원하지 않음)
//소수부를 무시 3.1은 3이 되고 -1.1은 -1이 됩니다

//위에서 소개한 내장 함수들만을도 소수부에 관련된 연사 ㄴ대부분을 처리할 수 있습니다. 그런데 소수점 n-th번째 수를 기준으로 어림수를 구해야 하는 상황이라면 어떻게 해야 할까요?
// 예를들어 1.2345가 있는데 소수점 두 번째 자리수 까지만 넘겨 1.23을 만들고 싶은 경우처럼 말이죠.

// 두가지 방법이 있습니다.
// 1.곱하기와 나누기
// 소수점 두번째 자리 숫자까지만 남기고 싶은 경우, 숫자에 100 또는 100보다 큰 10의 거듭제곱 수를 곱한 후 원하는 어림수 내장 함수를 호출하고 처음 곱한 수를 다시 나누면 됩니다.

let num = 1.23456;

alert(Math.floor(num*100)/100); //1.23456 -> 123.456 -> 123 -> 1.23

// 2. 소수점 n 번째 수까지의 어림수를 구한 후 이를 문자형으로 반환 해주는 메서드인 toFixed(n)를 사용합니다.

let num = 12.34;
alert(num.toFixed(1));

// toFixed는 Math.round와 유사하게 가장 가까운 값으로 올림 혹은 버림해줍니다.

let num = 12.36;
alert(num.toFixed(1)); //"12.4"

//toFixed를 사용할 때 주의할 점은 이 메서드의 반환값이 문자열이라는 것 입니다. 소수부의 길이가 인수보다 작으면 끝에 0이 추가됩니다.
let num = 12.34;
alert(num.toFixed(5));

//부정확한 계산
//숫자는 내부적으로 64비트 형식 IEEE-753으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요합니다.
// 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점위치를(정수는 0),1비트는 부호를 저장하는 데 사용됩니다.
//그런데 숫자가 너무 커지면 64비트 공간이 넘쳐서 INFINITY로 처리됩니다

alert(1e500) ; //Infinity

//원인을 이해하려면 집중이 필요하지만 꽤자주 발생하는 현상인 정밀도 손실도 있습니다.
//예시를 살펴봅시다.

alert(0.1+0.2 ==0.3); //false
//  0.1과 0.2의합이 0.3과 일치하는지 확인 했는데 false가 출력되었습니다.
// 이상하네요! 합의 결과가 0.3이 아니라면 대체 무엇일까요 ?

alert(0.1 + 0.2); //0.300000000000000000000004

// 부정확한 비교 연산이 만들어내는 결과는 여기서 그치지 않습니다. 인터넷 쇼핑몰 사이트를 운영하고 있다고 가정해봅시다.
// 사용자가 $0.10와 $0.20 짜리 물품을 장바구니에 넣었다고 상상해보죠. 주문총액이 $0.30000000000000000000004인것을 보고 놀라지 않을 사용자는 없을겁니다.


